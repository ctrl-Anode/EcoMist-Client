#include <ESP8266WiFi.h>
#include <WiFiManager.h>
#include <FirebaseESP8266.h>
#include <ArduinoJson.h>
#include <time.h>
#include <DHT.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <EEPROM.h>
#define EEPROM_SIZE 512
// ---------------- FIREBASE CONFIG ----------------
#define API_KEY "AIzaSyDI4-BnlhJz5BQflocmopqpEIsc6WoHiE0"
#define DATABASE_URL "https://ecomist-3082f-default-rtdb.asia-southeast1.firebasedatabase.app"
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ---------------- PINS ----------------
#define DHTPIN D8
#define DHTTYPE DHT22
#define TRIGGER_PIN D5
#define ECHO_PIN D6
#define PH_PIN A0
#define TDS_PIN A0
#define ONE_WIRE_BUS D7
#define MIST_PIN D4     // Relay control

// ---------------- SENSORS ----------------
DHT dht(DHTPIN, DHTTYPE);
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature ds18b20(&oneWire);

String machineId, basePath;
String lastActionPath;          

// ---------------- THRESHOLDS ----------------
struct Thresholds {
  float humidity_min = 50.0, humidity_max = 70.0;
  float air_temp_min = 18.0, air_temp_max = 25.0;
  float water_temp_min = 18.0, water_temp_max = 22.0;
  float water_level_min = 10.0;
  float ph_min = 5.5, ph_max = 6.5;
  float tds_min = 560.0, tds_max = 840.0;
} thresholds, defaultThresholds;

// ---------------- READINGS ----------------
float humidity = NAN, airTemp = NAN, waterTemp = NAN, distanceCm = NAN, phVal = NAN, tdsVal = NAN;

// ---------------- TIMING ----------------
unsigned long lastCheck = 0;
const unsigned long checkInterval = 5000; // 5 sec default
unsigned long mistStart = 0;
bool misting = false;

// ---------------- SIMULATION ----------------
bool simulationMode = false;        // live flag from Firebase
struct SimSettings {
  float humidity_drift_speed = 0.02;   // change per tick
  float temp_drift_speed = 0.01;
  float water_temp_drift_speed = 0.005;
  float noise = 0.5; // random noise magnitude
  int seed = 12345;
} simSettings;

// internal simulated state for gradual drift
float simHumidity = 60.0, simAirTemp = 23.0, simWaterTemp = 20.0, simDistance = 12.0, simPh = 6.0, simTds = 700.0;

// ---------------- FIREBASE PATHS ----------------
//String machineId, basePath;
String thresholdsPath, readingsPath, historyPath;
String mistPath, autoMistPath, scheduleMistPath;
String ssidPath, ipPath, statusPath, ownerPath, devicenamePath, registeredPath;
String reconnectPath, disconnectPath, wifiSsidPath, wifiPassPath, initializedPath;
String restoreDefaultThresholdPath, userDevicePath;
String simulationPath, simulationSettingsPath;

// ---------------- FUNCTION PROTOTYPES ----------------
void logError(const String &label);
void syncTime();
void readSensors();
void readSimulatedSensors();
void pushReadings();
void fetchThresholds();
void fetchSimulationMode();
void fetchSimulationSettings();
void checkMistAutomation();
void pushDefaultThresholds();
float randomFloat(float a, float b);
void ensureSimInitialisedIfNeeded();
void pushMistLog(const String &action);
void saveWiFiCredentialsToFirebase();
void saveWiFiCredentials(String ssid, String pass);
bool loadWiFiCredentials(String &ssid, String &pass);
void monitorWiFiStatus();

// ---------------- CLEANED WIFI FLOW ----------------
void initializeWiFi() {
  String savedSSID, savedPass;

  if (loadWiFiCredentials(savedSSID, savedPass)) {
    Serial.println("Attempting to connect using saved WiFi credentials...");
    WiFi.mode(WIFI_STA);

    for (int attempt = 1; attempt <= 3; attempt++) {
      WiFi.begin(savedSSID.c_str(), savedPass.c_str());

      unsigned long start = millis();
      while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
        delay(500);
        Serial.print(".");
      }

      if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\nConnected using saved credentials!");
        return;
      } else {
        Serial.printf("\nAttempt %d failed. Retrying in 30 seconds...\n", attempt);
        delay(30000); // 30-second delay between attempts
      }
    }

    // If all attempts fail, clear saved credentials
    Serial.println("\nFailed to connect after 3 attempts. Clearing saved WiFi credentials...");
    saveWiFiCredentials("", "");
  } else {
    Serial.println("No saved WiFi credentials found. Starting Config Portal...");
  }

  startWiFiManager();
}

void startWiFiManager() {
  WiFiManager wifiManager;
  wifiManager.setConfigPortalTimeout(180);
  if (!wifiManager.autoConnect("AeroTech-Setup")) {
    Serial.println("Failed to connect via portal, restarting...");
    delay(3000);
    ESP.restart();
  }
  Serial.println("WiFi connected: " + WiFi.SSID());
  Serial.println("IP: " + WiFi.localIP().toString());

  // Save WiFi credentials to EEPROM
  saveWiFiCredentials(WiFi.SSID(), WiFi.psk());

  // Save WiFi credentials and data to Firebase
  saveWiFiCredentialsToFirebase();
}

// ---------------- SETUP ----------------
void setup() {
  Serial.begin(115200);
  delay(1500);

  pinMode(MIST_PIN, OUTPUT);
  digitalWrite(MIST_PIN, LOW);

  dht.begin();
  ds18b20.begin();

  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  machineId = String(ESP.getChipId());
  Serial.printf("üöÄ Booting AeroTech Device - ID: %s\n", machineId.c_str());

  initializeWiFi();

  syncTime();

  auth.user.email = "ecomist111@gmail.com";
  auth.user.password = "Ecomist@111";
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  config.time_zone = 8; // Asia/Manila
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  basePath = "/devices/" + machineId;
  thresholdsPath = basePath + "/thresholds";
  readingsPath = basePath + "/sensor_readings/latest";
  historyPath = basePath + "/sensor_readings/history";
  mistPath = basePath + "/mist/manual";
  autoMistPath = basePath + "/mist/auto";
  scheduleMistPath = basePath + "/mist/schedule";
  simulationPath = basePath + "/simulation_mode";
  simulationSettingsPath = basePath + "/simulation_settings";

  ssidPath = basePath + "/state/connected_ssid";
  ipPath = basePath + "/state/ip_address";
  statusPath = basePath + "/status";
  ownerPath = basePath + "/owner";
  devicenamePath = basePath + "/devicename";
  registeredPath = basePath + "/registered";
  reconnectPath = basePath + "/state/reconnect";
  disconnectPath = basePath + "/state/disconnect";
  wifiSsidPath = basePath + "/state/wifi_ssid";
  wifiPassPath = basePath + "/state/wifi_password";
  lastActionPath = basePath + "/state/last_action_result";
  initializedPath = basePath + "/state/initialized";
  restoreDefaultThresholdPath = thresholdsPath + "/restore_defaults";
  userDevicePath = "/users/" + String(auth.token.uid.length() > 0 ? auth.token.uid.c_str() : "unknown") + "/devices/" + machineId;

  defaultThresholds = thresholds;

  Serial.println("üì§ Checking initial device info in Firebase...");
  if (!Firebase.getBool(fbdo, initializedPath) || !fbdo.boolData()) {
    if (!Firebase.setString(fbdo, ssidPath, WiFi.SSID())) logError("set ssid");
    if (!Firebase.setString(fbdo, ipPath, WiFi.localIP().toString())) logError("set ip");
    if (!Firebase.setString(fbdo, statusPath, "waiting_for_registration")) logError("set status");
    if (!Firebase.setString(fbdo, ownerPath, "Unregistered")) logError("set owner");
    if (!Firebase.setString(fbdo, devicenamePath, "Device-" + machineId)) logError("set devicename");
    if (!Firebase.setBool(fbdo, registeredPath, false)) logError("set registered");

    Firebase.setString(fbdo, basePath + "/credentials/email", "");
    Firebase.setString(fbdo, basePath + "/credentials/password", "");
    Firebase.setString(fbdo, basePath + "/admin/adminname", "EcoMist Admin");
    Firebase.setString(fbdo, basePath + "/admin/adminid", auth.token.uid.length() > 0 ? auth.token.uid.c_str() : "unknown");
    Firebase.setString(fbdo, basePath + "/admin/adminemail", auth.user.email.c_str());

    pushDefaultThresholds();

    Firebase.setBool(fbdo, initializedPath, true);
    Firebase.setBool(fbdo, simulationPath, false);
    Firebase.setFloat(fbdo, simulationSettingsPath + "/humidity_drift_speed", simSettings.humidity_drift_speed);
    Firebase.setFloat(fbdo, simulationSettingsPath + "/temp_drift_speed", simSettings.temp_drift_speed);
    Firebase.setFloat(fbdo, simulationSettingsPath + "/water_temp_drift_speed", simSettings.water_temp_drift_speed);
    Firebase.setFloat(fbdo, simulationSettingsPath + "/noise", simSettings.noise);
  }

  fetchThresholds();
  fetchSimulationMode();
  fetchSimulationSettings();
  ensureSimInitialisedIfNeeded();

  Serial.println("‚úÖ Device setup complete.");
}

// ---------------- LOOP ----------------
void loop() {
  unsigned long now = millis();
  if (Firebase.ready() && now - lastCheck >= checkInterval) {
    lastCheck = now;

    if (WiFi.status() == WL_CONNECTED) {
      Firebase.setInt(fbdo, basePath + "/last_online", time(nullptr));
      pushWiFiSignalStrength(); // Push WiFi signal strength to Firebase
    }

    // Check for WiFi commands from Firebase
    handleWiFiCommands();

    if (Firebase.getBool(fbdo, restoreDefaultThresholdPath) && fbdo.boolData()) {
      pushDefaultThresholds();
      Firebase.setBool(fbdo, restoreDefaultThresholdPath, false);
    }

    fetchThresholds();
    fetchSimulationMode();
    fetchSimulationSettings();

    if (simulationMode) {
      readSimulatedSensors();
    } else {
      readSensors();
    }

    pushReadings();
    checkMistAutomation();
  }

  // Monitor WiFi status continuously
  monitorWiFiStatus();
}

void handleWiFiCommands() {
  bool commandProcessed = false;

  // Reset WiFi command
  if (Firebase.getBool(fbdo, basePath + "/state/reset_wifi") && fbdo.boolData()) {
    Serial.println("Reset WiFi command received.");

    // Clear the flag IMMEDIATELY to prevent looping
    if (Firebase.setBool(fbdo, basePath + "/state/reset_wifi", false)) {
      Serial.println("Cleared reset_wifi flag from Firebase.");
    } else {
      Serial.println("Warning: Failed to clear reset_wifi flag, but proceeding with reset.");
    }

    // Clear saved credentials from EEPROM
    saveWiFiCredentials("", "");
    Serial.println("Cleared WiFi credentials from EEPROM.");

    // Start WiFi Manager for reconfiguration
    WiFi.disconnect(); // Ensure WiFi is disconnected before starting the manager
    startWiFiManager();

    Firebase.setString(fbdo, lastActionPath, "WiFi reset and reconfigured");
    commandProcessed = true;
  }

  if (commandProcessed) {
    Serial.println("WiFi command processed.");
  }
}

// ---------------- HELPERS ----------------
void logError(const String &label) {
  Serial.print("‚ùå Failed to ");
  Serial.print(label);
  Serial.print(": ");
  Serial.println(fbdo.errorReason());
}

void syncTime() {
  Serial.println("üïí Syncing time with NTP...");
  configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov");
  time_t now = time(nullptr);
  while (now < 100000) {
    delay(500);
    Serial.print(".");
    now = time(nullptr);
  }
  Serial.println();
  Serial.printf("‚úÖ Time synced: %ld\n", now);
}

// small random float
float randomFloat(float a, float b) {
  return a + ((float)rand() / (float)RAND_MAX) * (b - a);
}

// ---------------- FETCHERS ----------------
void fetchThresholds() {
  // Only update fields that exist; otherwise keep previous
  if (Firebase.getFloat(fbdo, thresholdsPath + "/humidity_min")) thresholds.humidity_min = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/humidity_max")) thresholds.humidity_max = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/air_temp_min")) thresholds.air_temp_min = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/air_temp_max")) thresholds.air_temp_max = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/water_temp_min")) thresholds.water_temp_min = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/water_temp_max")) thresholds.water_temp_max = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/water_level_min")) thresholds.water_level_min = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/ph_min")) thresholds.ph_min = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/ph_max")) thresholds.ph_max = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/tds_min")) thresholds.tds_min = fbdo.floatData();
  if (Firebase.getFloat(fbdo, thresholdsPath + "/tds_max")) thresholds.tds_max = fbdo.floatData();
}

void fetchSimulationMode() {
  if (Firebase.getBool(fbdo, simulationPath)) {
    simulationMode = fbdo.boolData();
  }
}

void fetchSimulationSettings() {
  // Read optional settings (if present) and override defaults
  float v;
  if (Firebase.getFloat(fbdo, simulationSettingsPath + "/humidity_drift_speed")) {
    v = fbdo.floatData();
    if (v >= 0 && v < 2.0) simSettings.humidity_drift_speed = v;
  }
  if (Firebase.getFloat(fbdo, simulationSettingsPath + "/temp_drift_speed")) {
    v = fbdo.floatData();
    if (v >= 0 && v < 2.0) simSettings.temp_drift_speed = v;
  }
  if (Firebase.getFloat(fbdo, simulationSettingsPath + "/water_temp_drift_speed")) {
    v = fbdo.floatData();
    if (v >= 0 && v < 2.0) simSettings.water_temp_drift_speed = v;
  }
  if (Firebase.getFloat(fbdo, simulationSettingsPath + "/noise")) {
    v = fbdo.floatData();
    if (v >= 0 && v < 10.0) simSettings.noise = v;
  }
}

// ensure simulated internal state starts in reasonable place
void ensureSimInitialisedIfNeeded() {
  if (isnan(simHumidity) || simHumidity < 0) simHumidity = (thresholds.humidity_min + thresholds.humidity_max) / 2.0;
  if (isnan(simAirTemp) || simAirTemp < -50) simAirTemp = (thresholds.air_temp_min + thresholds.air_temp_max) / 2.0;
  if (isnan(simWaterTemp) || simWaterTemp < -50) simWaterTemp = (thresholds.water_temp_min + thresholds.water_temp_max) / 2.0;
  if (isnan(simDistance) || simDistance <= 0) simDistance = thresholds.water_level_min + 5.0;
  if (isnan(simPh) || simPh <= 0) simPh = (thresholds.ph_min + thresholds.ph_max) / 2.0;
  if (isnan(simTds) || simTds <= 0) simTds = (thresholds.tds_min + thresholds.tds_max) / 2.0;
}

// ---------------- READERS ----------------
void readSensors() {
  // DHT22
  float h = dht.readHumidity();
  float at = dht.readTemperature();
  humidity = isfinite(h) ? h : NAN;
  airTemp = isfinite(at) ? at : NAN;

  // Ultrasonic
  digitalWrite(TRIGGER_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIGGER_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);
  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  distanceCm = duration > 0 ? (duration * 0.0343 / 2.0) : NAN;

  // DS18B20
  ds18b20.requestTemperatures();
  float wt = ds18b20.getTempCByIndex(0);
  waterTemp = (wt > -100 && wt < 150) ? wt : NAN;

  // pH
  float voltage = 0;
  const int samples = 10;
  for (int i = 0; i < samples; ++i) {
    voltage += analogRead(PH_PIN) * (5.0 / 1024.0);
    delay(5);
  }
  voltage /= samples;
  // crude formula (preserve your conversion)
  phVal = 7.0 + ((2.5 - voltage) / ((2.5 - 3.1) / 3.0));
  if (phVal < 0 || phVal > 14) phVal = NAN;

  // TDS
  float total = 0;
  for (int i = 0; i < samples; ++i) {
    total += analogRead(TDS_PIN);
    delay(5);
  }
  float v = total / samples * 5.0 / 1024.0;
  float compV = v / (1.0 + 0.02 * (isnan(waterTemp) ? 25.0 : (waterTemp - 25.0)));
  tdsVal = 133.42 * pow(compV, 3) - 255.86 * pow(compV, 2) + 857.39 * compV;
  if (tdsVal < 0 || tdsVal > 3000) tdsVal = NAN;

  // Serial debug
  Serial.printf("REAL READS -> Hum: %.2f Air: %.2f Water: %.2f Dist: %.2f pH: %.2f TDS: %.2f\n",
                humidity, airTemp, waterTemp, distanceCm, phVal, tdsVal);
}

void readSimulatedSensors() {
  // Ensure internal sim vars initialized
  ensureSimInitialisedIfNeeded();

  // Gentle drift toward random tiny target values near thresholds
  float targetHumidity = randomFloat(thresholds.humidity_min - 2.0, thresholds.humidity_max + 2.0);
  float deltaH = (targetHumidity - simHumidity) * simSettings.humidity_drift_speed;
  simHumidity += deltaH + randomFloat(-simSettings.noise, simSettings.noise) * 0.01;

  float targetAirTemp = randomFloat(thresholds.air_temp_min - 1.0, thresholds.air_temp_max + 1.0);
  float deltaAT = (targetAirTemp - simAirTemp) * simSettings.temp_drift_speed;
  simAirTemp += deltaAT + randomFloat(-simSettings.noise, simSettings.noise) * 0.01;

  float targetWaterTemp = randomFloat(thresholds.water_temp_min - 0.5, thresholds.water_temp_max + 0.5);
  float deltaWT = (targetWaterTemp - simWaterTemp) * simSettings.water_temp_drift_speed;
  simWaterTemp += deltaWT + randomFloat(-simSettings.noise, simSettings.noise) * 0.01;

  // distance sim: stable but can slightly vary; can be tied to mist consumption in future
  simDistance += randomFloat(-0.2, 0.2);

  // pH and TDS drift slowly toward nominal zone
  float targetPh = randomFloat(thresholds.ph_min - 0.2, thresholds.ph_max + 0.2);
  simPh += (targetPh - simPh) * 0.02 + randomFloat(-0.02, 0.02);

  float targetTds = randomFloat(thresholds.tds_min - 50, thresholds.tds_max + 50);
  simTds += (targetTds - simTds) * 0.01 + randomFloat(-2.0, 2.0);

  // clamp to reasonable ranges
  simHumidity = constrain(simHumidity, 0.0, 100.0);
  simAirTemp = constrain(simAirTemp, -10.0, 60.0);
  simWaterTemp = constrain(simWaterTemp, -10.0, 60.0);
  simDistance = fmax(simDistance, 0.0f);
  simPh = constrain(simPh, 0.0, 14.0);
  simTds = constrain(simTds, 0.0, 5000.0);

  // set readable globals
  humidity = simHumidity;
  airTemp = simAirTemp;
  waterTemp = simWaterTemp;
  distanceCm = simDistance;
  phVal = simPh;
  tdsVal = simTds;

  Serial.printf("SIM READS -> Hum: %.2f Air: %.2f Water: %.2f Dist: %.2f pH: %.2f TDS: %.2f\n",
                humidity, airTemp, waterTemp, distanceCm, phVal, tdsVal);
}

// ---------------- PUSH READINGS ----------------
void pushReadings() {
  String timestamp = String(time(nullptr));
  String histPath = historyPath + "/" + timestamp;

  // Latest (include simulated flag)
  Firebase.setFloat(fbdo, readingsPath + "/humidity", humidity);
  Firebase.setFloat(fbdo, readingsPath + "/airTemp", airTemp);
  Firebase.setFloat(fbdo, readingsPath + "/waterTemp", waterTemp);
  Firebase.setFloat(fbdo, readingsPath + "/distance", distanceCm);
  if (!isnan(phVal)) Firebase.setFloat(fbdo, readingsPath + "/ph", phVal);
  if (!isnan(tdsVal)) Firebase.setFloat(fbdo, readingsPath + "/tds", tdsVal);
  Firebase.setBool(fbdo, readingsPath + "/simulated", simulationMode);
  Firebase.setInt(fbdo, readingsPath + "/timestamp", time(nullptr));

  // History snapshot
  Firebase.setFloat(fbdo, histPath + "/humidity", humidity);
  Firebase.setFloat(fbdo, histPath + "/airTemp", airTemp);
  Firebase.setFloat(fbdo, histPath + "/waterTemp", waterTemp);
  Firebase.setFloat(fbdo, histPath + "/distance", distanceCm);
  if (!isnan(phVal)) Firebase.setFloat(fbdo, histPath + "/ph", phVal);
  if (!isnan(tdsVal)) Firebase.setFloat(fbdo, histPath + "/tds", tdsVal);
  Firebase.setBool(fbdo, histPath + "/simulated", simulationMode);
  Firebase.setInt(fbdo, histPath + "/timestamp", time(nullptr));
}

// ---------------- DEFAULT THRESHOLDS ----------------
void pushDefaultThresholds() {
  Firebase.setFloat(fbdo, thresholdsPath + "/humidity_min", defaultThresholds.humidity_min);
  Firebase.setFloat(fbdo, thresholdsPath + "/humidity_max", defaultThresholds.humidity_max);
  Firebase.setFloat(fbdo, thresholdsPath + "/air_temp_min", defaultThresholds.air_temp_min);
  Firebase.setFloat(fbdo, thresholdsPath + "/air_temp_max", defaultThresholds.air_temp_max);
  Firebase.setFloat(fbdo, thresholdsPath + "/water_temp_min", defaultThresholds.water_temp_min);
  Firebase.setFloat(fbdo, thresholdsPath + "/water_temp_max", defaultThresholds.water_temp_max);
  Firebase.setFloat(fbdo, thresholdsPath + "/water_level_min", defaultThresholds.water_level_min);
  Firebase.setFloat(fbdo, thresholdsPath + "/ph_min", defaultThresholds.ph_min);
  Firebase.setFloat(fbdo, thresholdsPath + "/ph_max", defaultThresholds.ph_max);
  Firebase.setFloat(fbdo, thresholdsPath + "/tds_min", defaultThresholds.tds_min);
  Firebase.setFloat(fbdo, thresholdsPath + "/tds_max", defaultThresholds.tds_max);
}

// ---------------- MIST AUTOMATION & LOGS ----------------
void pushMistLog(const String &action) {
  String path = basePath + "/mist/logs/" + String(time(nullptr));
  Firebase.setString(fbdo, path + "/action", action);
  Firebase.setFloat(fbdo, path + "/humidity", humidity);
  Firebase.setFloat(fbdo, path + "/waterTemp", waterTemp);
  Firebase.setBool(fbdo, path + "/simulated", simulationMode);
  Firebase.setInt(fbdo, path + "/timestamp", time(nullptr));
}

void checkMistAutomation() {
  // Manual
  bool manualMist = false;
  if (Firebase.getBool(fbdo, mistPath)) {
    manualMist = fbdo.boolData();
    Firebase.setBool(fbdo, mistPath, false); // consume manual command
  }

  // Auto flag
  bool autoMist = false;
  if (Firebase.getBool(fbdo, autoMistPath)) autoMist = fbdo.boolData();

  // Schedule
  int schedInterval = 3600, schedDuration = 5; // seconds
  if (Firebase.getInt(fbdo, scheduleMistPath + "/interval")) schedInterval = fbdo.intData();
  if (Firebase.getInt(fbdo, scheduleMistPath + "/duration")) schedDuration = fbdo.intData();

  unsigned long currentTimeSec = millis() / 1000;

  bool thresholdMist = false;
  if (autoMist) {
    if (!isnan(humidity) && humidity < thresholds.humidity_min) thresholdMist = true;
    if (!isnan(waterTemp) && waterTemp > thresholds.water_temp_max) thresholdMist = true;
  }

  // scheduled logic: periodic interval
  bool scheduled = (schedInterval > 0) ? (currentTimeSec % schedInterval < schedDuration) : false;

  bool turnOn = manualMist || thresholdMist || scheduled;

  if (turnOn) {
    if (!misting) {
      digitalWrite(MIST_PIN, HIGH);
      mistStart = millis();
      misting = true;
      Serial.println("üíß Mist ON");
      pushMistLog("ON");
    }
  } else {
    if (misting && millis() - mistStart >= 1000) {
      digitalWrite(MIST_PIN, LOW);
      misting = false;
      Serial.println("üíß Mist OFF");
      pushMistLog("OFF");
    }
  }
}

void saveWiFiCredentials(String ssid, String pass) {
  EEPROM.begin(EEPROM_SIZE);

  // Clear first 64 bytes (32 for SSID, 32 for password)
  for (int i = 0; i < 64; i++) EEPROM.write(i, 0);

  // Write SSID (max 31 chars + null terminator)
  for (int i = 0; i < ssid.length() && i < 31; i++) {
    EEPROM.write(i, ssid[i]);
  }
  EEPROM.write(ssid.length(), 0); // null terminator

  // Write password (max 31 chars + null terminator)
  for (int i = 0; i < pass.length() && i < 31; i++) {
    EEPROM.write(32 + i, pass[i]);
  }
  EEPROM.write(32 + pass.length(), 0);

  EEPROM.commit();
  EEPROM.end();
  Serial.println("WiFi credentials saved to EEPROM");
}

bool loadWiFiCredentials(String &ssid, String &pass) {
  EEPROM.begin(EEPROM_SIZE);

  char ssidBuffer[32] = {0};
  char passBuffer[32] = {0};

  for (int i = 0; i < 32; i++) {
    ssidBuffer[i] = EEPROM.read(i);
    if (ssidBuffer[i] == 0) break;
  }

  for (int i = 0; i < 32; i++) {
    passBuffer[i] = EEPROM.read(32 + i);
    if (passBuffer[i] == 0) break;
  }

  EEPROM.end();

  ssid = String(ssidBuffer);
  pass = String(passBuffer);

  if (ssid.length() > 0 && pass.length() > 0) {
    Serial.printf("Loaded saved WiFi: %s\n", ssid.c_str());
    return true;
  }
  return false;
}

void saveWiFiCredentialsToFirebase() {
  FirebaseJson stateUpdate;
  stateUpdate.set("connected_ssid", WiFi.SSID());
  stateUpdate.set("ip_address", WiFi.localIP().toString());
  stateUpdate.set("wifi_ssid", WiFi.SSID());
  stateUpdate.set("wifi_password", WiFi.psk());
  stateUpdate.set("last_action_result", "connected");

  if (Firebase.updateNode(fbdo, basePath + "/state", stateUpdate)) {
    Serial.println("WiFi credentials and data saved to Firebase successfully.");
  } else {
    Serial.print("Failed to save WiFi credentials to Firebase: ");
    Serial.println(fbdo.errorReason());
  }
}

void pushWiFiSignalStrength() {
  if (WiFi.status() == WL_CONNECTED) {
    int signalStrength = WiFi.RSSI(); // Get WiFi signal strength in dBm
    Firebase.setInt(fbdo, basePath + "/state/wifi_signal_strength", signalStrength);
    Serial.printf("WiFi Signal Strength: %d dBm\n", signalStrength);
  } else {
    Serial.println("WiFi not connected. Cannot push signal strength.");
  }
}

void monitorWiFiStatus() {
  static unsigned long lastDisconnectedTime = 0;
  static bool wasConnected = true;

  if (WiFi.status() != WL_CONNECTED) {
    if (wasConnected) {
      // Log disconnection event
      FirebaseJson log;
      log.set("event", "disconnected");
      log.set("timestamp", time(nullptr));
      Firebase.pushJSON(fbdo, basePath + "/wifi_logs", log);

      Serial.println("WiFi disconnected. Attempting to reconnect...");
      wasConnected = false;
      lastDisconnectedTime = millis();
    }

    // Attempt to reconnect if disconnected for more than 10 seconds
    if (millis() - lastDisconnectedTime > 10000) {
      String savedSSID, savedPass;
      if (loadWiFiCredentials(savedSSID, savedPass)) {
        WiFi.begin(savedSSID.c_str(), savedPass.c_str());
        Serial.println("Reconnecting using saved credentials...");

        unsigned long start = millis();
        while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
          delay(500);
          Serial.print(".");
        }

        if (WiFi.status() == WL_CONNECTED) {
          Serial.println("\nReconnected successfully!");
          FirebaseJson log;
          log.set("event", "reconnected");
          log.set("timestamp", time(nullptr));
          Firebase.pushJSON(fbdo, basePath + "/wifi_logs", log);
        } else {
          Serial.println("\nReconnection failed.");
          FirebaseJson log;
          log.set("event", "reconnection_failed");
          log.set("timestamp", time(nullptr));
          Firebase.pushJSON(fbdo, basePath + "/wifi_logs", log);
        }
      } else {
        Serial.println("No saved WiFi credentials available for reconnection.");
      }

      lastDisconnectedTime = millis(); // Reset timer after an attempt
    }
  } else {
    if (!wasConnected) {
      // Log reconnection event
      FirebaseJson log;
      log.set("event", "connected");
      log.set("timestamp", time(nullptr));
      Firebase.pushJSON(fbdo, basePath + "/wifi_logs", log);

      Serial.println("WiFi connection restored.");
      wasConnected = true;
    }
  }
}
